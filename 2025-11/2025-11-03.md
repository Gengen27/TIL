# OpenAI API の使い方 - 初学者向け完全解説

## はじめに

このドキュメントでは、実際に使用したRuby on Railsアプリケーションのコードを基に、OpenAI APIの使い方を初学者向けに解説します。

## システムの全体像

このシステムは4つのサービスで構成されています：

1. **AiEvaluationService** - 失敗記録を評価してスコアを付ける
2. **AiReflectionChecklistService** - 振り返り用チェックリストを生成
3. **AiIncompleteFeedbackService** - 未完了項目へのフィードバックを生成
4. **AiReflectionService** - 期間全体の振り返りを生成

---

## 1. 基本的な構成要素

**このセクションでは、OpenAI APIを使うために必要な最小限の設定を説明します。ライブラリの読み込みとAPIキーの設定の2つが基本です。**

### 0. `class ~~ end`とは何か？

**ファイルを開くと、必ず`class AiEvaluationService`と`end`があります。これは何をしているのでしょうか？**

#### クラスとは

**クラスは、関連する処理をまとめた「設計図」のようなものです。**

```ruby
class AiEvaluationService
  # ここに関連する処理を書く
end
```

**具体例で理解する：**

1. **クラスは「設計図」**
   ```ruby
   class AiEvaluationService
     # 「失敗記録を評価する」という機能の設計図
   end
   ```
   - 「失敗記録を評価する」という機能に関連する処理を、このクラスの中にまとめています

2. **実際に使う時は「インスタンス」を作る**
   ```ruby
   # 設計図から実際のものを作る
   service = AiEvaluationService.new(post)
   service.evaluate
   ```
   - `new`で実際のインスタンスを作成
   - そのインスタンスの`evaluate`メソッドを呼び出す

**なぜクラスを使うのか？**

1. **関連する処理をまとめる**
   - 失敗記録の評価に関わる処理（`evaluate`、`can_evaluate?`、`request_evaluation`など）を一箇所にまとめられる

2. **再利用できる**
   ```ruby
   # 同じクラスから複数のインスタンスを作れる
   service1 = AiEvaluationService.new(post1)
   service2 = AiEvaluationService.new(post2)
   ```

3. **整理されて読みやすい**
   - どの機能がどこにあるかわかりやすい

**実際のコード構造：**

```ruby
class AiEvaluationService
  # ↑ クラスの開始
  
  def initialize(post)
    # 初期化処理（クラスを使う準備）
  end
  
  def evaluate
    # 評価を実行する処理
  end
  
  private
  
  def can_evaluate?
    # 評価可能かチェック
  end
  
  def request_evaluation
    # APIを呼び出す
  end
  
  # ... 他のメソッド ...
  
end
# ↑ クラスの終了
```

**重要なポイント：**
- `class`と`end`の間にあるものが、そのクラスの「部品」です
- メソッド（`def ... end`）は、そのクラスが持つ「機能」です
- クラスは「設計図」、インスタンスは「実際のもの」です

**他のクラスも同じ構造：**

```ruby
class AiReflectionChecklistService
  # チェックリスト生成に関する処理をまとめる
end

class AiIncompleteFeedbackService
  # 未完了フィードバックに関する処理をまとめる
end
```

各クラスは、それぞれ異なる機能の「設計図」として働いています。

#### `attr_reader :post`とは何か？

コードの4行目に`attr_reader :post`があります。これは何をしているのでしょうか？

**`attr_reader`は、インスタンス変数を読み取るためのメソッドを自動生成するRubyの機能です。**

```ruby
class AiEvaluationService
  attr_reader :post  # ← これで`post`メソッドが自動的に作られる
  
  def initialize(post)
    @post = post      # インスタンス変数に保存
  end
end
```

**具体的に何をしているのか：**

1. **インスタンス変数`@post`を保存**
   ```ruby
   def initialize(post)
     @post = post  # 引数で受け取ったpostを、@postというインスタンス変数に保存
   end
   ```
   - `@`がつく変数（`@post`）は、そのクラスのインスタンス内で使える変数です

2. **`attr_reader :post`の効果**
   ```ruby
   attr_reader :post
   ```
   これは以下と同じ意味です：
   ```ruby
   def post
     @post  # インスタンス変数を返すメソッド
   end
   ```

3. **実際の使い方**
   ```ruby
   # インスタンスを作成
   service = AiEvaluationService.new(post)
   
   # attr_readerのおかげで、postメソッドが使える
   service.post  # => @postの値が返される
   ```

**なぜ`attr_reader`を使うのか？**

**方法1：`attr_reader`を使わない場合（長い）**
```ruby
class AiEvaluationService
  def initialize(post)
    @post = post
  end
  
  # 手動でメソッドを書く必要がある
  def post
    @post
  end
end
```

**方法2：`attr_reader`を使う場合（短い）**
```ruby
class AiEvaluationService
  attr_reader :post  # 1行で同じ機能が実現できる！
  
  def initialize(post)
    @post = post
  end
end
```

**実際のコードでの使用例：**

```ruby
class AiEvaluationService
  attr_reader :post
  
  def initialize(post)
    @post = post
  end
  
  def can_evaluate?
    # @postを使う代わりに、postメソッドでアクセスできる
    post.cause.present? && post.solution.present?
    # ↑ attr_reader :post のおかげで、postメソッドが使える
  end
end
```

**重要なポイント：**
- `attr_reader :post`は、`post`というメソッドを自動的に作る
- この`post`メソッドは、`@post`の値を返す
- 外部から`@post`に直接アクセスする代わりに、`post`メソッドでアクセスできる
- コードが簡潔になり、Rubyらしい書き方になる

**まとめ：**
- `attr_reader :post` = 「`@post`を読み取る`post`メソッドを自動生成してね」という意味
- 1行でメソッドを定義できる便利な機能

### 1-1. ライブラリの読み込み

```ruby
require 'openai'
```

- `openai` というgem（ライブラリ）を使用します
- このライブラリがOpenAI APIを呼び出すための機能を提供してくれます

### 1-2. APIキーの設定

**この部分では、OpenAI APIを使うためのクライアントオブジェクトを作成します。APIキーを使って認証を行います。**

```ruby
@client = OpenAI::Client.new(access_token: ENV['OPENAI_API_KEY'])
```

**重要なポイント：**
- `ENV['OPENAI_API_KEY']`: 環境変数からAPIキーを取得しています
- **セキュリティのため、APIキーはコードに直接書かず、環境変数で管理します**
- `@client`: OpenAI APIを呼び出すためのクライアントオブジェクトです

---

## 2. API呼び出しの基本パターン

**このセクションでは、実際にOpenAI APIを呼び出す方法と、返ってきたデータをどう処理するかを説明します。すべてのサービスで使われる基本パターンです。**

### 2-1. 基本的なAPI呼び出し

**この部分では、AIに質問を送信して回答を得る方法を説明します。モデルの選択、メッセージの組み立て、パラメータの設定が重要です。**

```ruby
response = @client.chat(
  parameters: {
    model: 'gpt-4-turbo-preview',
    messages: [
      { role: 'system', content: system_message },
      { role: 'user', content: prompt }
    ],
    temperature: 0.7,
    response_format: { type: 'json_object' }
  }
)
```

**各要素の説明：**

1. **`@client.chat(...)`**: Chat Completion APIを呼び出します
2. **`model: 'gpt-4-turbo-preview'`**: 使用するAIモデルを指定します
3. **`messages`**: 会話の流れを定義します
   - `system`: AIの役割や指示を設定（AIへの指示書）
   - `user`: ユーザーの質問や依頼内容
4. **`temperature: 0.7`**: 出力の多様性を設定（0.0〜2.0、高いほど多様な回答）
5. **`response_format: { type: 'json_object' }`**: JSON形式で返答してもらう

#### メッセージの「梱包」の仕組み

**重要な理解：メッセージは構造化されて送られます**

```ruby
messages: [
  { role: 'system', content: system_message },  # ← ここで「梱包」
  { role: 'user', content: prompt }
]
```

**具体的な流れ：**

1. **準備段階：**
   ```ruby
   # システムメッセージを準備（日本語文章）
   system_message = "あなたは失敗から学ぶことを支援するAIメンターです。..."
   
   # ユーザープロンプトを準備（日本語文章）
   prompt = "以下の失敗経験を評価してください。\n【タイトル】\nデータベース接続エラー..."
   ```

2. **梱包：**
   ```ruby
   messages = [
     {
       role: 'system',           # 「これはシステム設定だよ」というラベル
       content: system_message   # 実際の日本語文章
     },
     {
       role: 'user',             # 「これはユーザーの質問だよ」というラベル
       content: prompt           # 実際の日本語文章
     }
   ]
   ```

3. **APIに送信：**
   - この「梱包」されたメッセージが、JSON形式に変換されてAPIに送られます
   - AIは`role`を見て、「これは設定だな」「これは質問だな」と理解します

**なぜこの形式なのか？**

- **`role`**: AIに「このメッセージの種類」を教えるため
  - `system`: 「あなたの役割はこれです」という設定
  - `user`: 「ユーザーからの質問です」という意味
  - `assistant`: 「AIの返答です」（会話履歴を保持する場合に使用）

- **`content`**: 実際にAIが読む日本語の文章

**実際にAPIに送られるJSONの形（イメージ）：**
```json
{
  "model": "gpt-4-turbo-preview",
  "messages": [
    {
      "role": "system",
      "content": "あなたは失敗から学ぶことを支援するAIメンターです。..."
    },
    {
      "role": "user",
      "content": "以下の失敗経験を評価してください。..."
    }
  ],
  "temperature": 0.7,
  "response_format": { "type": "json_object" }
}
```

**まとめ：**
- 日本語文章（`system_message`、`prompt`）を、`{ role: ..., content: ... }`という形式で「梱包」
- この梱包されたメッセージの配列を`messages`として送信
- AIは`role`を見て、それぞれのメッセージを適切に処理する

### 2-2. レスポンスの処理

**この部分は、APIから返ってきた生データを、アプリケーションで使いやすい形に変換・加工する処理です。**

```ruby
content = response.dig('choices', 0, 'message', 'content')
tokens_used = response.dig('usage', 'total_tokens')

result = JSON.parse(content)
result['tokens_used'] = tokens_used
result
```

#### ステップバイステップ解説

**ステップ1: APIレスポンスからテキストを取得**

```ruby
content = response.dig('choices', 0, 'message', 'content')
```

- `response.dig(...)`: ネストしたハッシュから値を安全に取得
- `'choices'`: APIの返答候補（通常は1つ）
- `'message'`: メッセージ内容
- `'content'`: 実際のテキスト

**実際のレスポンス構造：**
```ruby
response = {
  'choices' => [
    {
      'message' => {
        'content' => '{"cause_analysis_score": 20, "total_score": 75, ...}'
      }
    }
  ],
  'usage' => {
    'total_tokens' => 150
  }
}
```

この時点で、`content`には**文字列**としてJSONデータが入っています：
```ruby
content = '{"cause_analysis_score": 20, "total_score": 75, ...}'
```

**ステップ2: トークン使用量を取得**

```ruby
tokens_used = response.dig('usage', 'total_tokens')
```

APIの使用量を記録しておきます。この値は数値（例: `150`）です。

**ステップ3: JSON文字列をRubyのハッシュに変換**

```ruby
result = JSON.parse(content)
```

**なぜこれが必要なのか？**

- `content`は**文字列**です。文字列のままでは、データを扱えません
- `JSON.parse`で文字列をRubyの**ハッシュ（辞書のようなもの）**に変換します

**変換前（文字列）：**
```ruby
content = '{"cause_analysis_score": 20, "total_score": 75}'
content.class  # => String（文字列）
```

**変換後（ハッシュ）：**
```ruby
result = {
  "cause_analysis_score" => 20,
  "total_score" => 75
}
result.class  # => Hash（ハッシュ）
```

これで、`result['cause_analysis_score']`のように値にアクセスできます。

**ステップ4: トークン使用量を結果に追加**

```ruby
result['tokens_used'] = tokens_used
```

AIの返答データに、トークン使用量を追加します。

**最終的な`result`の形：**
```ruby
result = {
  "cause_analysis_score" => 20,
  "total_score" => 75,
  "feedback_comment" => "良い分析です...",
  "tokens_used" => 150  # ← 追加された
}
```

**ステップ5: 結果を返す**

```ruby
result
```

このハッシュを返すことで、後続の処理でデータを使えます。

---

## 3. 各サービスファイルの詳しい解説

**このセクションでは、実際のサービスファイルごとに、何をしているのか、どう動作するのかを詳しく解説します。同じパターンを繰り返し使っていることがわかります。**

### 3-1. AiEvaluationService - 失敗記録の評価

**このサービスは、ユーザーが記録した失敗内容をAIが評価し、スコアとフィードバックを返します。失敗の分析がどれだけ深いか、対策が具体的かを数値で評価します。**

#### 目的
ユーザーの失敗記録をAIが評価し、スコアとフィードバックを返します

#### 処理の流れ

```ruby
def evaluate
  return false unless can_evaluate?  # 評価可能かチェック

  begin
    response = request_evaluation    # OpenAI APIを呼び出す
    save_ai_score(response)          # 結果をデータベースに保存
    true
  rescue StandardError => e
    Rails.logger.error "AI Evaluation Error: #{e.message}"
    false
  end
end
```

**重要：これらのメソッドはどこで定義されているのか？**

`can_evaluate?`、`request_evaluation`、`save_ai_score`は、**このクラス（AiEvaluationService）内で定義されたメソッド**です。標準のコマンドやライブラリではなく、このサービス専用に作られた関数（メソッド）です。

```ruby
class AiEvaluationService
  # ... 他のコード ...
  
  private  # ← これ以降は外部から直接呼べないプライベートメソッド

  def can_evaluate?
    # 評価可能かチェックする処理
  end

  def request_evaluation
    # OpenAI APIを呼び出す処理
  end

  def save_ai_score(response)
    # 結果をデータベースに保存する処理
  end
end
```

**ステップ説明：**
1. **`can_evaluate?`**: 評価可能かチェック（APIキーが存在するか、必要なデータがあるか）※クラス内で定義されたメソッド
2. **`request_evaluation`**: OpenAI APIを呼び出す ※クラス内で定義されたメソッド
3. **`save_ai_score`**: 結果をデータベースに保存 ※クラス内で定義されたメソッド
4. **エラーが発生した場合**: ログに記録してfalseを返す

**なぜこのように分割するのか？**
- **可読性向上**: 大きな処理を小さなメソッドに分けることで、コードが読みやすくなる
- **再利用性**: 同じ処理を複数の場所で使える
- **保守性**: 修正が必要な時、該当するメソッドだけを直せばよい

#### システムメッセージ（AIへの指示）

システムメッセージでは、AIに「どんな役割で、どんな形式で返答するか」を指示します。

**`<<~MSG ... MSG`とは何か？**

これは**Rubyのヒアドキュメント**という機能で、複数行の文字列を書きやすくするための記法です。

```ruby
base_message = <<~MSG
  あなたは失敗から学ぶことを支援するAIメンターです。
  ユーザーの失敗経験を分析し、建設的なフィードバックを提供してください。
MSG
```

**重要なポイント：**

1. **コードではなく、普通の日本語文章**
   - `<<~MSG`と`MSG`の間には、**コードではなく日本語の文章**を書きます
   - この文章が**そのままAIに送信される**内容です

2. **実際にAPIに送られる内容**
   ```ruby
   response = @client.chat(
     parameters: {
       messages: [
         { role: 'system', content: system_message },  # ← ここで使われる
         { role: 'user', content: prompt }
       ]
     }
   )
   ```
   `system_message`メソッドが返す文字列（ヒアドキュメントで書いた日本語）が、`content`としてAPIに送られます。

3. **なぜこの書き方をするのか？**
   - 通常の文字列だと、改行や引用符の扱いが面倒：
     ```ruby
     # 通常の書き方（見にくい）
     message = "あなたは失敗から学ぶことを支援するAIメンターです。\nユーザーの失敗経験を分析し..."
     ```
   - ヒアドキュメントなら、そのまま自然に書ける：
     ```ruby
     # ヒアドキュメント（見やすい）
     message = <<~MSG
       あなたは失敗から学ぶことを支援するAIメンターです。
       ユーザーの失敗経験を分析し...
     MSG
     ```

**実際の例：**

```ruby
def system_message
  base_message = <<~MSG
    あなたは失敗から学ぶことを支援するAIメンターです。
    ユーザーの失敗経験を分析し、建設的なフィードバックを提供してください。
    
    評価基準：
    1. 原因分析の深さ (0-25点): 失敗の根本原因を深く理解しているか
    2. 対策の具体性 (0-25点): 再発防止策が具体的で実行可能か
  MSG
  # ↑ この文章が、そのままAIに送られる
end
```

**まとめ：**
- `<<~MSG ... MSG`は複数行文字列を書くRubyの記法
- 中身は**普通の日本語文章**
- その文章が**そのままAPIに送られてAIが読む**
- 評価基準を明確に定義
- JSON形式で返答するよう指定
- ユーザーの好みに応じてトーンを調整（gentle, strict, logical, balanced）

#### プロンプト（ユーザーからの質問）

プロンプトでは、AIに分析してほしい具体的なデータを渡します。

**こちらも同じくヒアドキュメントで日本語を書いています：**

```ruby
def build_prompt
  <<~PROMPT
    以下の失敗経験を評価してください。

    【タイトル】
    #{post.title}

    【失敗内容】
    #{post.content}

    【原因分析】
    #{post.cause}

    【対策】
    #{post.solution}

    【学び】
    #{post.learning}

    【カテゴリ】
    #{post.category.name}
  PROMPT
end
```

**重要なポイント：**

1. **`<<~PROMPT ... PROMPT`もヒアドキュメント**
   - システムメッセージと同じく、普通の日本語文章を書きます
   - この文章がAIに「質問」として送られます

2. **`#{post.title}`などは変数の埋め込み**
   - `#{...}`の部分だけがコードで、実際のデータに置き換わります
   - 例：`#{post.title}` → 実際の投稿タイトル（例：「データベース接続エラー」）
   - これを**文字列補間**といいます

3. **実際にAPIに送られる例：**
   ```
   以下の失敗経験を評価してください。

   【タイトル】
   データベース接続エラー

   【失敗内容】
   アプリケーションがデータベースに接続できませんでした...

   【原因分析】
   接続文字列の設定ミスでした...

   【対策】
   環境変数で接続情報を管理するようにしました...
   ```
   このような形で、**実際のデータを含んだ日本語文章**がAIに送られます。

---

### 3-2. AiReflectionChecklistService - チェックリスト生成

**このサービスは、失敗記録を振り返るためのチェックリストを自動生成します。1日後、3日後、7日後など、期間ごとに適切な振り返り項目を作成します。**

同じパターンで、システムメッセージで「振り返り用チェックリストを生成する」よう指示します。期間ごと（1日後、3日後、7日後など）のチェックリスト項目を生成します。

---

### 3-3. AiIncompleteFeedbackService - 未完了項目へのフィードバック

**このサービスは、振り返りチェックリストで未完了の項目があった場合、AIが建設的なフィードバックを生成します。責めるのではなく、次回に向けたアドバイスを提供します。**

未完了の振り返り項目について、AIが建設的なフィードバックを生成します。

---

### 3-4. AiReflectionService - 期間全体の振り返り

**このサービスは、一定期間（例：1ヶ月）の失敗記録をまとめて分析し、成長の軌跡や改善点を総評します。エラーハンドリングの良い実例でもあります。**

#### エラーハンドリングの実例

```ruby
def request_reflection
  # ... API呼び出し ...
  
  content = response.dig('choices', 0, 'message', 'content')
  
  if content.blank?
    Rails.logger.error "AI Reflection: Empty response from API"
    raise StandardError, "AI API returned empty response"
  end
  
  parsed_response = JSON.parse(content)
  
  # 必要なキーが存在することを確認
  unless parsed_response.is_a?(Hash) && parsed_response['summary'].present?
    Rails.logger.error "AI Reflection: Invalid response format"
    raise StandardError, "AI API returned invalid response format"
  end
  
  parsed_response
rescue JSON::ParserError => e
  Rails.logger.error "AI Reflection JSON Parse Error: #{e.message}"
  raise StandardError, "Failed to parse AI response: #{e.message}"
end
```

**ポイント：**
- レスポンスが空でないか確認
- JSON形式が正しいか確認
- 必要なキーが存在するか確認
- `rescue JSON::ParserError`: JSONパースエラーを捕捉

---

## 4. 共通パターンまとめ

**このセクションでは、すべてのサービスで共通して使われているパターンをまとめます。このパターンを覚えれば、新しいサービスも作れるようになります。**

### パターン1: 基本構造

全てのサービスで以下のような構造になっています：

```ruby
class AiXxxService
  def initialize(...)
    @client = OpenAI::Client.new(access_token: ENV['OPENAI_API_KEY'])
  end

  def execute
    return false unless can_execute?  # 前処理チェック
    
    begin
      response = request_to_ai        # API呼び出し
      save_result(response)           # 結果保存
      true
    rescue StandardError => e
      Rails.logger.error "Error: #{e.message}"
      false
    end
  end
end
```

### パターン2: API呼び出し

```ruby
response = @client.chat(
  parameters: {
    model: 'gpt-4-turbo-preview',
    messages: [
      { role: 'system', content: system_message },
      { role: 'user', content: prompt }
    ],
    temperature: 0.7,
    response_format: { type: 'json_object' }
  }
)

content = response.dig('choices', 0, 'message', 'content')
result = JSON.parse(content)
```

### パターン3: エラーハンドリング

```ruby
begin
  # API呼び出しの処理
rescue StandardError => e
  Rails.logger.error "Error: #{e.message}"
  false  # または nil を返す
end
```

---

## 5. 重要な概念まとめ

**このセクションでは、OpenAI APIを使う上で重要な用語や概念を表形式でまとめています。辞書としても使えます。**

| 概念 | 説明 | コード例 |
|------|------|----------|
| **APIキー** | OpenAIアカウントで発行する認証キー | `ENV['OPENAI_API_KEY']` |
| **クライアント** | APIを呼び出すためのオブジェクト | `OpenAI::Client.new(...)` |
| **モデル** | 使用するAIモデル | `'gpt-4-turbo-preview'` |
| **システムメッセージ** | AIの役割や指示を設定 | `{ role: 'system', ... }` |
| **ユーザーメッセージ** | 実際の質問や依頼 | `{ role: 'user', ... }` |
| **レスポンス** | APIから返ってくるデータ | `response.dig(...)` |
| **トークン** | API使用量の単位（詳しくは下記参照） | `response.dig('usage', 'total_tokens')` |

#### トークンとは何か？

**トークンは、OpenAI APIの使用量を測る単位です。** 日本語では「単語」のようなものですが、厳密には単語とは異なります。

**具体例：**
- 日本語：約1-2文字が1トークン
- 英語：約4文字（0.75単語）が1トークン

**例：**
```
"こんにちは" → 約5トークン
"Hello" → 約1トークン
"失敗ログ分析システム" → 約9トークン
```

**なぜトークン使用量が重要なのか？**
1. **コスト計算**: OpenAI APIは使用したトークン数に応じて課金されます
2. **レート制限**: 1分間や1日に使えるトークン数に制限があります
3. **効率化**: トークン数を減らすことで、コストと処理時間を削減できます

**トークン使用量の内訳：**
- **入力トークン**: 送信したメッセージ（システムメッセージ + ユーザープロンプト）に使用されたトークン
- **出力トークン**: AIが返答した内容に使用されたトークン
- **合計トークン**: 入力 + 出力

**実際のコードでの取得方法：**
```ruby
tokens_used = response.dig('usage', 'total_tokens')  # 合計トークン数
input_tokens = response.dig('usage', 'prompt_tokens') # 入力トークン数
output_tokens = response.dig('usage', 'completion_tokens') # 出力トークン数
```

**目安：**
- 短い質問と回答: 50-200トークン
- 中程度の分析: 200-1000トークン
- 長文の分析: 1000-4000トークン以上

---

## 6. 実際のコードから学ぶポイント

**このセクションでは、実際のコードから学べる重要なポイントを4つ紹介します。実践的な知識として役立ちます。**

### ポイント1: 環境変数の使用
セキュリティのため、APIキーは環境変数で管理：
```ruby
ENV['OPENAI_API_KEY']
```

### ポイント2: バリデーション
APIを呼び出す前に、必要なデータが揃っているか確認：
```ruby
def can_evaluate?
  ENV['OPENAI_API_KEY'].present? && post.cause.present? && post.solution.present?
end
```

### ポイント3: JSON形式の指定
構造化されたデータが必要な場合、JSON形式で返答してもらう：
```ruby
response_format: { type: 'json_object' }
```

### ポイント4: トーンの調整
ユーザーの好みに応じて、AIの回答スタイルを変更：
```ruby
case personality
when 'gentle'
  # 優しいトーン
when 'strict'
  # 厳しいトーン
end
```

---

## 7. よくある質問（FAQ）

**このセクションでは、よくある質問とその回答をまとめています。疑問に思ったときに参照してください。**

### Q1: APIキーはどこで取得しますか？
A: OpenAIの公式サイト（https://platform.openai.com/）でアカウントを作成し、APIキーを発行します。

### Q2: `temperature`の値はどう選びますか？
A: 
- **0.0-0.3**: 一貫性が重要（評価、分析など）
- **0.7**: バランス型（一般的な用途）
- **0.8-1.0**: 創造性が重要（アイデア出しなど）

### Q3: エラーが発生したらどうしますか？
A: `begin...rescue`でエラーを捕捉し、ログに記録して適切に処理します。ユーザーにはfalseやnilを返します。

### Q4: トークン使用量はなぜ記録するの？
A: 以下の理由から重要です：
- **コスト管理**: OpenAI APIはトークン数に応じて課金されるため、使用量を把握することで費用を管理できます
- **レート制限の確認**: APIには1分間や1日あたりの使用制限があるため、制限を超えないように監視する必要があります
- **効率化**: トークン数を記録することで、どの処理が多くトークンを使っているか把握し、最適化のヒントが得られます
- **トラブルシューティング**: エラーが発生した際に、使用トークン数を確認することで問題の原因を特定できる場合があります

---

## 8. 理解度チェック問題

**このセクションでは、理解度を確認するための問題を用意しています。自分の理解を深めるために試してみてください。**

以下の問題を考えてみましょう：

1. **APIキーを環境変数で管理する理由は？**
   - ヒント：セキュリティの観点から考えてみましょう

2. **`system_message`と`prompt`の違いは？**
   - ヒント：systemは「役割設定」、userは「具体的な質問」です

3. **`response_format: { type: 'json_object' }`を使う理由は？**
   - ヒント：返答を構造化されたデータとして扱いたい場合に使用します

4. **エラーハンドリングで`begin...rescue`を使う理由は？**
   - ヒント：API呼び出しは外部サービスなので、失敗する可能性があります

---

## 9. 次のステップ

**このセクションでは、さらに学習を進めるための具体的なステップを紹介します。実践を通して理解を深めましょう。**

1. **実際にコードを読む**: 各サービスファイルを開いて、実際のコードと照らし合わせてみましょう
2. **パラメータを変更してみる**: `temperature`の値を変えて、出力の違いを確認してみましょう
3. **エラーパターンを理解する**: どんなエラーが発生する可能性があるか考えてみましょう
4. **新しいサービスを作ってみる**: 同じパターンで新しい機能を追加してみましょう

---

## 10. 参考資料

**このセクションでは、さらに詳しく学ぶための参考資料を紹介します。公式ドキュメントなどを確認することで、より深く理解できます。**

- [OpenAI API公式ドキュメント](https://platform.openai.com/docs)
- [Ruby OpenAI Gem](https://github.com/alexrudall/ruby-openai)

---

## まとめ

OpenAI APIを使う基本的な流れ：

1. **クライアントの初期化**: APIキーを使ってクライアントを作成
2. **メッセージの準備**: システムメッセージとユーザープロンプトを作成
3. **API呼び出し**: `@client.chat`でAPIを呼び出す
4. **レスポンスの処理**: 返ってきたデータをパースして使用
5. **エラーハンドリング**: エラーが発生した場合の処理を実装

このパターンを覚えれば、様々なAI機能を実装できるようになります！

